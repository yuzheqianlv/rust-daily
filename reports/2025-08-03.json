{
  "date": "2025-08-03T01:09:53.782577006Z",
  "items": [
    {
      "title": "Cargo new --workspace",
      "link": "https://internals.rust-lang.org/t/cargo-new-workspace/23313",
      "description": "Fairly simple proposal: add a --workspace flag to cargo that adds the newly created package to workspace.members in the current project’s Cargo.toml. This small tweak would make workspaces a lot more ergonomic to use. 4 posts - 2 participants Read full topic",
      "pub_date": "2025-08-02T17:13:46Z",
      "source": "Rust Internals"
    },
    {
      "title": "Safe narrowing casts in some cases",
      "link": "https://internals.rust-lang.org/t/safe-narrowing-casts-in-some-cases/23312",
      "description": "Probably I discussed part of this in past, but there's more material here, and it's sometimes good to repeat a bit, to be heard. In my code I try to avoid \"as\" casts where possible (and Clippy agrees), but also filling your code with `try_from(_).ok().unwrap()` isn't awesome. Thankfully there are ways to avoid both in some cases. I've created three simple abstractions that help in many cases in my code (they push the \"as\" cast in the library code). Sqrt returns half of the number of bits of the input, so you can use to narrow an integer type. And operations return a number of bits of the smallest of the two, so I sometimes use them with an implicit narrowing cast. Something similar happens with the % operation. You can guess that I'd like those three in the std lib // narrowing_isqrt ------------------------- // Not usable with usize/isize. #[const_trait] trait NarrowingIsqrt { type Out; fn narrowing_isqrt(&self) -> Self::Out; } impl const NarrowingIsqrt for i32 { type Out = u16; #[inline(always)] fn narrowing_isqrt(&self) -> Self::Out { self.isqrt() as _ } } impl const NarrowingIsqrt for u32 { type Out = u16; ... } // narrowing_and ------------------------- #[const_trait] trait NarrowingAnd<Out> { fn narrowing_and(&self, other: Out) -> Out; } impl const NarrowingAnd<u32> for u64 { #[inline] fn narrowing_and(&self, other: u32) -> u32 { (*self & Self::from(other)) as _ } } impl const NarrowingAnd<u8> for u32 { ... } // mul_mod ------------------------- trait MulModCast where Self: ZeroablePrimitive { fn mul_mod(self, b: Self, m: NonZero<Self>) -> Self; } impl MulModCast for u32 { #[inline] fn mul_mod(self, b: Self, m: NonZero<Self>) -> Self { (u64::from(self) * u64::from(b)).narrowing_rem(m) } } impl MulModCast for u64 { #[inline(always)] #[cfg(not(target_arch = \"x86_64\"))] fn mul_mod(self, b: Self, m: Self::NonZero) -> Self { (u128::from(self) * u128::from(b)).narrowing_rem(Self::get(m)) } // Performs `(a * b) % m` efficiently on 128 bits in asm. #[inline(always)] #[allow(unused_assignments, unused_variables)] #[cfg(target_arch = \"x86_64\")] fn mul_mod(self, b: Self, m: NonZero<Self>) -> Self { ... } } //---------------------------------------------------- (Apparently all my browsers “will soon be incompatible with this community.”) 1 post - 1 participant Read full topic",
      "pub_date": "2025-08-02T16:25:33Z",
      "source": "Rust Internals"
    },
    {
      "title": "Stabilizing Linker Relaxation for RISC-V",
      "link": "https://internals.rust-lang.org/t/stabilizing-linker-relaxation-for-risc-v/23311",
      "description": "Hi all! Looking to start a conversation about what it would take to stabilize the RISC-V “relax” target feature which was added a few years back. Linker relaxation is an important optimization for RISC-V (according to SiFive, “it has greatly shaped the design of the RISC-V ISA.”). We’re using it for Tock OS to realize something on the order of a 10% space savings for RISC-V targets. But this triggers a noisy compiler warning due to the feature being unstable. What does the path look like for this feature to become stable? (And as an aside, is there or should there be some mechanism to opt out of warnings for compiler features?) 1 post - 1 participant Read full topic",
      "pub_date": "2025-08-02T14:42:37Z",
      "source": "Rust Internals"
    },
    {
      "title": "Any() doc is ambiguous",
      "link": "https://internals.rust-lang.org/t/any-doc-is-ambiguous/23310",
      "description": "I understood “any() is short-circuiting; in other words, it will stop processing” as saying it will stop checking. I was surprised that this also stops a preceding map() retroactively, skipping my intended side effects. Not saying this is wrong or right – I guess there are use cases for either behaviour. But just like rayon states such behaviour explicitly, so should std! 12 posts - 8 participants Read full topic",
      "pub_date": "2025-08-02T14:16:28Z",
      "source": "Rust Internals"
    },
    {
      "title": "[Idea] Faster derive(Hash) for types without padding",
      "link": "https://internals.rust-lang.org/t/idea-faster-derive-hash-for-types-without-padding/23305",
      "description": "Hi everyone, I am new here. After reading a blog post about hashing in Rust I was thinking how the situation could be improved. My first thought was that if Rust had an equivalent of C++’s has_unique_object_representations then derive Hash could use it to generate potentially faster implementations for types that do not have padding. Something like this code: pub unsafe fn obj_as_bytes<T>(obj: &T) -> &[u8] { let byte_ptr = std::ptr::from_ref(obj).cast::<u8>(); let byte_len = std::mem::size_of_val(obj); unsafe { std::slice::from_raw_parts(byte_ptr, byte_len) } } pub unsafe fn obj_slice_as_bytes<T>(obj_slice: &[T]) -> &[u8] { let byte_ptr = obj_slice.as_ptr().cast::<u8>(); let byte_len = std::mem::size_of_val(obj_slice); unsafe { std::slice::from_raw_parts(byte_ptr, byte_len) } } impl Hash for Foo { fn hash<H: Hasher>(&self, state: &mut H) { state.write(unsafe { obj_as_bytes(&self.0) }); } fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized, { state.write(unsafe { obj_slice_as_bytes(data) }); } } Would it be possible? Doesn’t it break any Rust rules? Am I missing something? I tested the idea using different hashers and the results look promising. Bench results for std DefaultHasher and Foo being struct { u16, u16, char }. test bool_hash_slice_custom_unsafe  ... bench:          13.72 ns/iter (+/- 0.05) test bool_hash_slice_derived        ... bench:          36.19 ns/iter (+/- 0.05) test char_hash_slice_custom_unsafe  ... bench:          17.92 ns/iter (+/- 0.29) test char_hash_slice_derived        ... bench:          38.66 ns/iter (+/- 0.11) test foo_hash_one_custom_unsafe     ... bench:           9.41 ns/iter (+/- 0.03) test foo_hash_one_derived           ... bench:          16.88 ns/iter (+/- 0.17) test foo_hash_slice_1_custom_unsafe ... bench:          13.84 ns/iter (+/- 0.04) test foo_hash_slice_1_derived       ... bench:          21.14 ns/iter (+/- 0.06) test foo_hash_slice_2_custom_unsafe ... bench:          15.24 ns/iter (+/- 0.02) test foo_hash_slice_2_derived       ... bench:          32.12 ns/iter (+/- 0.34) test foo_hash_slice_4_custom_unsafe ... bench:          19.66 ns/iter (+/- 0.02) test foo_hash_slice_4_derived       ... bench:          54.43 ns/iter (+/- 1.14) test foo_hash_slice_8_custom_unsafe ... bench:          24.08 ns/iter (+/- 0.08) test foo_hash_slice_8_derived       ... bench:         103.34 ns/iter (+/- 1.87) 9 posts - 5 participants Read full topic",
      "pub_date": "2025-08-02T07:01:19Z",
      "source": "Rust Internals"
    },
    {
      "title": "How is reactor shared across threads when running tokio multithreaded?",
      "link": "https://users.rust-lang.org/t/how-is-reactor-shared-across-threads-when-running-tokio-multithreaded/132572",
      "description": "Just the title. I am currently building a very basic async runtime to learn the internals and am using a thread local for storing and accessing the reactor. If there are multiple threads, how is shared access provided to the individual workers to a single reactor? Or are there multiple reactors? 3 posts - 2 participants Read full topic",
      "pub_date": "2025-08-02T20:57:28Z",
      "source": "Rust Users Forum"
    },
    {
      "title": "Arm cortex-m4 #[inline(never)] creates bigger firmware size?",
      "link": "https://users.rust-lang.org/t/arm-cortex-m4-inline-never-creates-bigger-firmware-size/132569",
      "description": "I have this one shot timer function from Discovery book stm32f3 discovery: #[inline(never)] fn delay(tim6: &tim6::RegisterBlock, ms: u16) { // Set the timer to go off in `ms` ticks // 1 tick = 1 ms tim6.arr.write(|w| w.arr().bits(ms)); // CEN: Enable the counter tim6.cr1.modify(|_, w| w.cen().set_bit()); // Wait until the alarm goes off (until the update event occurs) while !tim6.sr.read().uif().bit_is_set() {} // Clear the update event flag tim6.sr.modify(|_, w| w.uif().clear_bit()); } This function then gets called repeatedly and infinitely from the main loop. When I check its size with GNU binutils size command. Release size: text    data     bss     dec     hex filename 5916       0       4    5920    1720 target/thumbv7em-none-eabihf/release/clocks-and-timers When I remove #[inline(never)], release size: text    data     bss     dec     hex filename 5828       0       4    5832    16c8 target/thumbv7em-none-eabihf/release/clocks-and-timers So it’s optimized slightly better without inline never? 4 posts - 3 participants Read full topic",
      "pub_date": "2025-08-02T17:16:10Z",
      "source": "Rust Users Forum"
    },
    {
      "title": "Website Downloader using Rust",
      "link": "https://users.rust-lang.org/t/website-downloader-using-rust/132558",
      "description": "Fox2Web - Website Downloader A fast and efficient website downloader written in Rust. Features Download HTML pages Download and organize assets (CSS, JS, Images) Automatic directory structure creation URL path correction for local viewing Progress bar for asset downloads Colorful terminal output Fast and concurrent downloads Github: GitHub - code3-dev/Fox2Web: A fast and efficient website downloader written in Rust. 3 posts - 3 participants Read full topic",
      "pub_date": "2025-08-02T13:28:40Z",
      "source": "Rust Users Forum"
    },
    {
      "title": "Rust for billions of MCUs",
      "link": "https://users.rust-lang.org/t/rust-for-billions-of-mcus/132551",
      "description": "I am posting on this board because it's more about the roadmap of the Rust language. I have been working on an IoT platform that brings Apps to the IoT world. Apps are designed to be \"write once, run everywhere.\" There is no need to address the benefit of running Apps that interact with the world locally on devices. The Typescript API and implementation have already been finalized. But it is hard to make decisions on the Rust implementation. The Microcontrollers are very resource-limited (a few hundred KB of RAM/ROM). The design needs to aim for maximum code reuse. But Rust ABI has never been stable. Forcing App developers to publish their source code is an option, but I'm afraid it will negatively affect adoption, which will ultimately hurt users. I would appreciate thoughts and insights from you guys. The Thing-App design: Libertas IoT Documentation Thing-App and Task Software development guide smartonlabs.com Libertas IoT Smartonlabs Libertas IoT 14 posts - 7 participants Read full topic",
      "pub_date": "2025-08-02T12:51:29Z",
      "source": "Rust Users Forum"
    },
    {
      "title": "Cross-platform abstract design",
      "link": "https://users.rust-lang.org/t/cross-platform-abstract-design/132548",
      "description": "I aim to implement platform abstraction where callers use a unified interface without platform-specific logic. My initial approach returned platform-specific types directly via conditional compilation: // -- snap -- pub trait BtDevice { fn disconnect(&self) -> Result<(), Box<dyn std::error::Error>>; } ​ #[derive(Default)] pub struct WindowsBtDevice; ​ #[derive(Default)] pub struct LinuxBtDevice; ​ #[derive(Default)] pub struct MacOSBtDevice; ​ #[derive(Default)] pub struct UnknownBtDevice; ​ pub struct Device; ​ impl Device { #[cfg(target_os = \"windows\")] pub fn new() -> WindowsBtDevice { WindowsBtDevice::default() } #[cfg(target_os = \"linux\")] pub fn new() -> LinuxBtDevice { LinuxBtDevice::default() } #[cfg(target_os = \"macos\")] pub fn new() -> MacOSBtDevice { MacOSBtDevice::default() } #[cfg(not(any(target_os = \"windows\", target_os = \"linux\", target_os = \"macos\")))] pub fn new() -> UnkonwnBtDevice { UnknownBtDevice::default() } } ​ impl BtDevice for WindowsBtDevice { fn disconnect(&self) -> Result<(), Box<dyn std::error::Error>> { // do_something... } } ​ Copilot Reviewer recommended refactoring to return a unified Deviceenum encapsulating all platforms: // -- snap -- pub trait BtDevice { fn disconnect(&self) -> Result<(), Box<dyn std::error::Error>>; } ​ #[derive(Default)] pub struct WindowsBtDevice; ​ #[derive(Default)] pub struct LinuxBtDevice; ​ #[derive(Default)] pub struct MacOSBtDevice; ​ #[derive(Default)] pub struct UnknownBtDevice; ​ pub enum Device { Windows(WindowsBtDevice), Linux(LinuxBtDevice), MacOS(MacOSBtDevice), Unknown(UnknownBtDevice), } ​ impl Device { pub fn new() -> Self { #[cfg(target_os = \"windows\")] { Device::Windows(WindowsBtDevice::default()) } #[cfg(target_os = \"linux\")] { Device::Linux(LinuxBtDevice::default()) } #[cfg(target_os = \"macos\")] { Device::MacOS(MacOSBtDevice::default()) } #[cfg(not(any(target_os = \"windows\", target_os = \"linux\", target_os = \"macos\")))] { Device::Unknown(UnknownBtDevice::default()) } } } ​ impl BtDevice for Device { fn disconnect(&self) -> Result<(), Box<dyn std::error::Error>> { match self { // i don't like this :< Device::Windows(device) => device.disconnect(), Device::Linux(device) => todo!(), Device::MacOS(device) => todo!(), Device::Unknown(device) => todo!(), } } } ​ impl BtDevice for WindowsBtDevice { fn disconnect(&self) -> Result<(), Box<dyn std::error::Error>> { // do_something... } } ​ My concern: The match in BtDevice for Device requires boilerplate delegation for every platform variant. Is this enum-based design truly beneficial compared to the initial approach? 2 posts - 2 participants Read full topic",
      "pub_date": "2025-08-02T11:47:44Z",
      "source": "Rust Users Forum"
    }
  ],
  "summary": "今日 Rust 社区动态聚焦于编译器工具链优化和嵌入式开发实践：Cargo 即将支持原生 workspace 创建功能，RISC-V 平台的链接器优化进入稳定阶段；同时社区深入探讨了无填充类型的高效哈希派生方案和 Tokio 运行时在多线程环境下的反应器共享机制。嵌入式领域特别关注 Cortex-M4 的代码生成优化和 MCU 大规模应用方案。\n\n讨论：Cargo new --workspace\n-----------------\n\n[讨论要点总结]\n该讨论提出了一个改进 Cargo 工作区体验的提案：为 `cargo new` 命令添加 `--workspace` 标志。当前在已有工作区项目中创建新 crate 时，需要手动将新包添加到 workspace.members 中。该提案建议自动完成这一步骤，使工作区管理更加符合人体工程学。\n\n技术细节：\n- 提案建议 `cargo new --workspace` 会自动将新创建的包添加到当前项目的 Cargo.toml 的 workspace.members 部分\n- 该功能特别适合大型项目和多 crate 工作区管理\n- 讨论中提出了可能的实现路径，包括检测当前目录是否在工作区中等\n\n实用价值：\n- 简化工作区管理流程，减少手动编辑 Cargo.toml 的需求\n- 降低工作区使用的认知负担，特别是对新手更友好\n- 与现有工作区功能无缝集成，不会引入破坏性变更\n\n\"[重要观点引用]\"\n\"这看起来是个小改变，但能显著改善工作区体验，特别是对那些经常需要添加新 crate 到工作区的大型项目。\"\n\nReddit：[讨论链接](https://internals.rust-lang.org/t/cargo-new-workspace/23313)\n\n讨论：安全窄化类型转换的实践方案\n-----------------\n\n该讨论提出了在Rust中安全处理整数窄化转换的几种实用方案，旨在避免直接使用`as`强制转换和冗长的`try_from`链式调用。\n\n### 讨论要点总结\n\n1. **问题背景**：\n   - Rust中直接使用`as`进行窄化转换存在潜在风险\n   - 使用`try_from().ok().unwrap()`虽然安全但代码冗长\n   - 需要更优雅的类型转换解决方案\n\n2. **提出的解决方案**：\n   - `narrowing_isqrt` trait：计算输入整数位数的平方根，返回缩小一半位数的类型\n   - `narrowing_and` trait：执行按位与操作并自动窄化到较小类型\n   - `mul_mod` trait：实现高效的大数模运算，自动处理类型转换\n\n3. **技术实现细节**：\n   - 使用const trait实现编译期优化\n   - 针对不同整数类型提供特化实现\n   - 针对x86_64架构提供特殊的汇编优化实现\n   - 通过trait系统保证类型安全\n\n4. **实际应用价值**：\n   - 加密算法中的模运算\n   - 图形处理中的位操作\n   - 需要精确控制整数大小的系统编程场景\n\n5. **社区建议**：\n   - 讨论是否应该将这些trait纳入标准库\n   - 探讨在不同架构上的性能优化方案\n   - 考虑与现有整数处理API的整合方式\n\n\"在代码中我尽量避免使用'as'强制转换(和Clippy的建议一致)，但到处使用`try_from(_).ok().unwrap()`也不理想。幸运的是在某些情况下我们可以两者都避免。\"\n\nReddit：[讨论链接](https://internals.rust-lang.org/t/safe-narrowing-casts-in-some-cases/23312)\n\n讨论：Stabilizing Linker Relaxation for RISC-V\n-----------------\n\n[讨论要点总结]\n- 讨论围绕将RISC-V架构的\"relax\"链接器松弛功能稳定化的必要性展开\n- 链接器松弛是RISC-V架构的重要优化技术，根据SiFive的说法\"它极大地影响了RISC-V ISA的设计\"\n- 目前在Tock OS中使用该功能可为RISC-V目标带来约10%的空间节省\n- 但由于该功能仍处于不稳定状态，会触发编译器警告\n- 讨论重点包括：\n  * 该功能稳定化的具体路径\n  * 是否需要提供机制来禁用编译器对不稳定功能的警告\n  * 该优化对嵌入式系统开发的实际价值评估\n\n\"[重要观点引用]\"\n\"根据我们在Tock OS中的使用经验，链接器松弛能为RISC-V目标带来约10%的空间节省，这对资源受限的嵌入式系统至关重要。\"\n\nReddit：[讨论链接](https://internals.rust-lang.org/t/stabilizing-linker-relaxation-for-risc-v/23311)\n\n[技术背景补充]\n链接器松弛(Linker Relaxation)是RISC-V特有的优化技术，它允许链接器在最终链接阶段根据实际内存布局优化指令序列。这种优化特别适合RISC-V的可变长度指令集架构，能够：\n1. 将长跳转指令替换为短跳转指令\n2. 优化内存访问指令\n3. 减少不必要的对齐填充\n这些优化能显著减小最终二进制文件的大小，对嵌入式系统开发尤为重要。\n\n讨论：Any() doc is ambiguous\n-----------------\n\n关于标准库中 `Iterator::any()` 方法文档表述模糊性的技术讨论。\n\n### 讨论要点总结\n\n1. **问题核心**：\n   - 当前文档将 `any()` 描述为\"短路\"行为（\"short-circuiting\"），但未明确说明这会\"回溯性\"地跳过前置 `map()` 操作中的副作用\n   - 用户期望文档能像 Rayon 那样明确说明迭代器适配器的完整行为影响\n\n2. **技术细节**：\n   - `any(f)` 在找到首个满足条件的元素时会立即返回，同时会丢弃迭代器中剩余元素\n   - 这意味着前置的 `map(f)` 中的副作用对于未被处理的元素将不会执行\n   - 这种行为在涉及 I/O 或其他重要副作用的场景中可能导致意外结果\n\n3. **争议点**：\n   - 有参与者认为这是迭代器应有的合理行为\n   - 也有观点认为文档应该更明确地警告这种副作用跳过行为\n\n4. **解决方案建议**：\n   - 改进文档表述，明确说明短路行为对前置适配器的影响\n   - 参考 Rayon 的文档风格，增加行为说明的显式程度\n\n\"[重要观点引用]\"\n\"就像 rayon 明确声明这种行为一样，std 也应该这样做！\"\n\n### 对 Rust 生态的意义\n\n这个讨论凸显了标准库文档在描述复杂行为时的精确性需求，特别是当涉及：\n- 迭代器组合的副作用传播\n- 方法链式调用的隐式行为\n- 用户对\"短路\"语义的不同理解\n\n该讨论可能推动标准库文档改进，使其在行为描述上更加明确和全面。\n\nReddit：[讨论链接](https://internals.rust-lang.org/t/any-doc-is-ambiguous/23310)\n\n讨论：为无填充类型实现更快的 derive(Hash)\n-----------------\n\n该讨论提出了一种优化 Rust 中 `#[derive(Hash)]` 性能的新思路，主要针对没有内存填充(padding)的类型。作者从 C++ 的 `has_unique_object_representations` 特性获得启发，建议通过直接操作内存字节来提升哈希计算效率。\n\n### 技术要点\n\n1. **核心提案**：\n   - 使用 `unsafe` 代码直接将类型内存表示转换为字节切片\n   - 提供了两个关键函数：\n     - `obj_as_bytes`: 将单个对象转换为字节切片\n     - `obj_slice_as_bytes`: 将对象切片转换为连续字节\n\n2. **性能优势**：\n   - 基准测试显示显著性能提升（2-4倍）\n   - 特别在处理切片时优势明显（如8元素切片从103ns降至24ns）\n\n3. **实现细节**：\n   - 使用 `std::ptr::from_ref` 和指针转换\n   - 依赖 `std::mem::size_of_val` 获取内存大小\n   - 需要确保类型确实没有填充字节\n\n### 潜在问题与讨论\n\n1. **安全性考量**：\n   - 必须确保类型确实没有填充字节\n   - 需要考虑对齐(alignment)问题\n   - 可能违反 Rust 的安全保证\n\n2. **替代方案**：\n   - 引入类似 C++ 的类型特征(trait)来标记\"无填充\"类型\n   - 编译器自动优化 `derive(Hash)` 实现\n\n3. **社区反馈**：\n   - 有参与者指出需要考虑平台相关行为\n   - 建议先作为第三方库验证概念\n\n### 实际价值\n\n该优化对于需要高频计算哈希的场景（如哈希表操作）有重要意义，特别是：\n- 游戏开发中的实体系统\n- 大数据处理中的键值计算\n- 网络协议中的校验和计算\n\n\"[...基准测试显示对于 struct { u16, u16, char } 类型，单个对象哈希从16.88ns降至9.41ns，8元素切片从103.34ns降至24.08ns...]\"\n\nReddit：[讨论链接](https://internals.rust-lang.org/t/idea-faster-derive-hash-for-types-without-padding/23305)\n\n讨论：多线程环境下 Tokio 的 Reactor 共享机制\n-----------------\n\n该讨论围绕 Tokio 运行时在多线程环境中如何共享 Reactor 这一核心组件展开，主要探讨了以下技术要点：\n\n1. **问题背景**：\n   - 提问者正在构建简易异步运行时学习内部机制\n   - 当前实现使用线程局部存储(thread-local)访问 Reactor\n   - 对多线程环境下 Reactor 的共享机制存在疑问\n\n2. **技术解析**：\n   - Tokio 的多线程运行时采用单 Reactor 多 Worker 架构\n   - Reactor 通过无锁队列和原子操作实现线程间共享\n   - 关键数据结构使用 Arc 实现跨线程共享所有权\n   - I/O 事件通过 epoll/kqueue 等系统调用集中处理\n\n3. **实现对比**：\n   - 与提问者的 thread-local 方案不同，Tokio 使用全局共享模式\n   - 通过 Parker/Unparker 机制唤醒阻塞线程\n   - 工作窃取(work-stealing)调度器优化任务分配\n\n4. **性能考量**：\n   - 单 Reactor 减少系统调用开销\n   - 避免多 Reactor 的竞态条件\n   - 通过批处理优化 I/O 事件通知\n\n\"在 Tokio 的多线程运行时中，虽然每个 worker 线程都有自己的任务队列，但它们共享同一个 Reactor 实例。这是通过原子引用计数和内部可变性模式精心设计的，确保线程安全的同时最小化同步开销。\"\n\n该讨论对理解 Tokio 的并发模型设计有重要价值，特别适合：\n- 异步运行时开发者\n- 需要深度优化 I/O 性能的工程师\n- 学习高级并发编程模式的研究者\n\n阅读：[原文链接](https://users.rust-lang.org/t/how-is-reactor-shared-across-threads-when-running-tokio-multithreaded/132572)\n\n讨论：Arm cortex-m4 #[inline(never)] 导致固件体积增大？\n-----------------\n\n[讨论要点总结]\n该讨论围绕在 ARM Cortex-M4 嵌入式开发中，使用 `#[inline(never)]` 属性对固件体积的影响展开。用户发现一个简单的定时器函数在添加该属性后，生成的固件体积反而比不加时更大，这与预期行为相反。\n\n技术细节分析：\n- 讨论中的定时器函数 `delay()` 用于 STM32F3 Discovery 开发板，通过操作 TIM6 定时器实现毫秒级延时\n- 使用 GNU binutils 的 size 命令测量显示：\n  * 带 `#[inline(never)]`：5916 字节\n  * 不带该属性：5828 字节\n- 差异达 88 字节，表明编译器在未强制不内联时能进行更好的优化\n\n可能原因探讨：\n1. 内联优化可能允许编译器消除重复的寄存器操作\n2. 循环展开等优化在内联后更有效\n3. Cortex-M4 的特定架构特性可能影响优化效果\n4. LLVM 后端对 thumbv7em 目标的优化策略\n\n\"[重要观点引用]\"\n\"这确实有些反直觉，因为 #[inline(never)] 通常用于减少代码体积（通过避免重复内联）。但在某些情况下，特别是小型、频繁调用的函数，强制不内联可能会阻止编译器进行更积极的优化。\"\n\n实际开发建议：\n- 在嵌入式开发中应实际测量不同属性下的代码大小\n- 对于频繁调用的小函数，谨慎使用 #[inline(never)]\n- 考虑使用 #[inline] 或让编译器自主决定\n\n该讨论揭示了 Rust 在嵌入式领域优化行为的复杂性，提醒开发者不能仅凭直觉使用编译器属性，而应通过实际测量来验证优化效果。\n\n阅读：[原文链接](https://users.rust-lang.org/t/arm-cortex-m4-inline-never-creates-bigger-firmware-size/132569)\n\nFox2Web：基于 Rust 的高效网站下载工具\n--------------\n\nFox2Web 是一个用 Rust 编写的网站下载工具，旨在提供快速高效的整站下载功能，适合开发者、内容存档和离线浏览等场景。\n\n### 项目详细介绍：\n\n**项目目标和解决的问题**\n- 解决传统网站下载工具速度慢、资源组织混乱的问题\n- 提供完整的网站镜像功能，包括 HTML 页面和所有关联资源\n- 自动处理本地查看时的路径修正问题\n\n**主要功能特点**\n* 完整的 HTML 页面下载功能\n* 自动下载并组织 CSS、JavaScript 和图片等资源\n* 根据 URL 结构自动创建本地目录层级\n* 智能 URL 路径修正，确保本地浏览效果与线上一致\n* 带进度条的资源下载显示\n* 彩色终端输出增强可读性\n* 基于 Rust 的并发下载实现，显著提升下载速度\n\n**技术特色和创新点**\n- 使用 reqwest 库进行高效的 HTTP 请求\n- 利用 tokio 实现异步并发下载\n- 基于 select.rs 的 HTML 解析和资源链接提取\n- 智能路径处理算法确保本地资源链接正确性\n- 轻量级实现，无运行时依赖\n\n**使用示例**\n```bash\nfox2web https://example.com --output ./downloads\n```\n\n**与现有方案的对比**\n相比传统工具如 wget：\n- 更清晰的资源组织结构\n- 更好的本地浏览支持\n- 更直观的进度反馈\n- 更高的下载速度（得益于 Rust 的并发能力）\n\n[Reddit] | 仓库：[GitHub - code3-dev/Fox2Web](https://github.com/code3-dev/Fox2Web)\n\n讨论：Rust 在数十亿级 MCU 上的应用路线图\n-----------------\n\n[讨论要点总结]\n该讨论围绕如何将 Rust 应用于资源极度受限的物联网微控制器(MCU)环境展开，主要聚焦在以下技术挑战：\n\n1. **资源限制问题**：\n   - 目标设备仅有几百KB的RAM/ROM\n   - 需要最大化代码复用率\n   - 现有TypeScript方案已完成但Rust实现面临抉择\n\n2. **ABI稳定性困境**：\n   - Rust ABI不稳定性导致二进制兼容性问题\n   - 强制开源可能影响开发者采用率\n   - 需要权衡二进制分发与开发者体验\n\n3. **架构设计考量**：\n   - \"一次编写，到处运行\"的IoT应用设计理念\n   - 本地设备交互应用的特殊需求\n   - 与Libertas IoT平台的集成方案\n\n\"[重要观点引用]\"\n\"在资源受限环境中，Rust的内存安全保证和零成本抽象理论上非常理想，但ABI不稳定性使得我们需要在二进制分发和开发者体验之间做出艰难取舍。\"\n\n该讨论对Rust在嵌入式领域的发展具有重要意义，特别是：\n- 揭示了Rust在超低资源环境下的实际应用障碍\n- 提出了语言设计路线图中需要考虑的嵌入式场景需求\n- 为IoT领域的Rust最佳实践提供了有价值的案例研究\n\n阅读：[原文链接](https://users.rust-lang.org/t/rust-for-billions-of-mcus/132551)\n\n讨论：跨平台抽象设计的最佳实践\n-----------------\n\n该讨论围绕如何在Rust中实现优雅的跨平台抽象展开，主要比较了两种不同的设计模式：\n\n### 技术要点分析\n1. **初始方案**：使用条件编译直接返回平台特定类型\n   - 通过`#[cfg]`属性根据目标平台返回不同的具体类型\n   - 优点：调用方直接获得具体类型，无需额外封装\n   - 缺点：API返回类型不统一，调用方需要处理平台差异\n\n2. **重构方案**：使用枚举封装所有平台变体\n   - 定义统一的`Device`枚举包含所有平台变体\n   - 优点：提供完全一致的接口，隐藏平台细节\n   - 缺点：需要为枚举实现trait时编写大量样板匹配代码\n\n### 核心争议点\n- **类型系统设计**：是否应该暴露平台特定类型给调用方\n- **代码维护性**：枚举方案的匹配代码是否会导致维护负担\n- **抽象成本**：统一接口带来的运行时匹配开销是否值得\n\n### 实用建议\n讨论中提出的折中方案：\n> \"可以考虑使用特征对象(dyn Trait)来避免枚举匹配的样板代码，同时保持接口统一\"\n\n### 对Rust生态的意义\n该讨论触及了Rust跨平台开发的核心模式选择问题，对以下场景有参考价值：\n- 系统级工具开发\n- 硬件抽象层设计\n- 跨平台库API设计\n\n[阅读完整讨论](https://users.rust-lang.org/t/cross-platform-abstract-design/132548)\n\n\n--\n\nFrom 日报小组 Rust Daily"
}