{
  "date": "2025-08-03T02:28:26.150144998Z",
  "items": [
    {
      "title": "rust实现三菱mc协议3e帧二进制通信",
      "link": "https://rustcc.cn/article?id=82c96c43-4d6a-4fd0-8656-e3b20c1ce9c3",
      "description": "🦀 Rust 实现三菱 PLC MC 协议（二进制 3E 帧）通信 最近我写了一个用 Rust 实现三菱 PLC MC 协议 3E 帧（二进制格式）通信的库，支持 bit/word 的读写。 📦 项目地址：tokio-mc GitHub 仓库 ✅ 支持特性 ✅ 支持三菱 3E 协议（二进制格式） ✅ 支持读写位（bit）/字（word）数据等数据 ✅ 支持异步（基于 tokio） ✅ 支持 Keyence 和  Mitsubishi PLC（仿三菱通信） ✅ 提供模拟服务器，方便测试 ✅ 架构参考 tokio-modbus，面向通用 PLC 通信而设计 🔧 架构设计与扩展性 该库使用模块化结构设计，底层通信解耦，后续可以轻松支持其他品牌 PLC（如松下）： 通信帧编码器/解码器可插拔 寄存器地址支持抽象封装 👉 计划支持目标： 松下 PLC 通信适配 扩展支持 ASCII 格式帧 提供 Python / C# / C++ FFI 调用封装 🚀 快速上手 use tokio_mc::{ client::tcp::*, frame::Model, }; #[tokio::main] async fn main() -> Result<(), Box<dyn std::error::Error>> { let mut context = connect(\"127.0.0.1:5000\".parse()?).await?; context.set_plc_model(Model::Mitsubishi); // or Model::Keyence // 写入 word 数据 context.write_u8s(\"D100\", &[0x12, 0x34]).await?; // 读取 bit 状态 let bits = context.read_bits(\"M0\", 8).await?; println!(\"Bits: {:?}\", bits); Ok(()) } Rust 在工业控制方向几乎没看到有三菱通信协议的实现（Modbus 倒是很多） 想做成一个 跨平台 + 跨语言 的通用 PLC 通信库，提供 FFI（Python/C#/C++）接口。 🎯 项目初衷 -为工业自动化通信打造一个高性能、高可扩展性的通用库 -填补 Rust 在 PLC 通信协议方面的空白 💬 欢迎交流 如果你从事工业控制、PLC 通信、异步架构或希望参与开源协议栈的开发，欢迎： 🔧 issue / PR 🌟 Star 支持 🧵 参与讨论",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-08-03 文章《添加隐式 auto-trait bounds 很困难》",
      "link": "https://rustcc.cn/article?id=747007e1-afd7-4d9d-accd-046b0d946c42",
      "description": "半月刊：The Embedded Rustacean Issue #51 阅读：https://www.theembeddedrustacean.com/p/the-embedded-rustacean-issue-51 文章《添加隐式 auto-trait bounds 很困难》 作者：lcnr（Rust Types Team Lead） 这篇文章探讨了在 Rust 中添加隐式自动特征（auto-trait）边界时面临的挑战。作者指出，添加隐式自动特征边界（如 Leak、Moveable 和 MetaSized）可以带来诸多好处，但同时也存在显著的性能成本。 特别是当这些特征的实现不局限于指针间接层时，会导致编译时间大幅增加。例如，为 TyCtxt 添加一个较少检查的自动特征会导致编译时间增加 7 秒，而全面支持额外的默认自动特征会使编译时间从 7 分钟延长到 33 分钟。 尽管通过优化可以部分缓解性能问题，但完全避免这些性能退化是不可能的。此外，作者还提到，如果隐式特征不局限于指针间接层，可能会导致其他问题，如需要增加递归限制和触发错误的协程生命周期错误。 阅读：https://lcnr.de/blog/2025/07/28/implicit-auto-trait-bounds.html 文章《测试 GCC 的 Rust 编译器后端》 这篇文章主要介绍了作者在修复基于 GCC 的 Rust 编译器后端（rustc_codegen_gcc）中的工作。 文章指出，编译器的正确性至关重要，而编译器的复杂性使得查找和修复错误变得困难。 作者通过使用一个名为 rustlantis 的工具生成 Rust 中间表示（MIR）代码，来测试编译器的正确性。 通过大量模糊测试，作者发现了一些编译器错误，并详细介绍了如何通过最小化代码来定位和修复这些错误。 此外，文章还探讨了如何通过 ABI 测试来验证 GCC 和 LLVM 编译的 Rust 代码之间的兼容性，以及如何改进对新平台（如 Motorola 6800）的支持。 作者强调了测试在编译器开发中的重要性，并分享了在修复编译器错误过程中遇到的挑战和解决方案。 阅读：https://fractalfir.github.io/generated_html/cg_gcc_bootstrap_2.html Reddit：https://www.reddit.com/r/rust/comments/1mb1o7q/testing_the_gccbased_rust_compilerbackend/ 视频：Vibe coding complex changes in Rust 关注我的人可能早就知道，我对机器学习多少有点“卢德分子”情调——倒不是反对用 ML 工具，而是这些工具在我的日常工作中一直派不上用场，尤其在编程这件事上。我之前的假设是：这多少跟我的工作性质有关——它通常并不适合 ML 最擅长的“模式复刻”，也就是那种已经有大量现成样本供模型学习的场景。 最近，“氛围编程（vibe coding）”被炒得火热，尤其是像 Claude Code 这类“代理式”AI 编程助手。于是我决定“真刀真枪”地试一次。具体说，我打算给一个做类型安全的刚体变换的 Rust crate——Sguaba（https://github.com/helsing-ai/sguaba ）——做一些不算简单的改动。Sguaba 代码量不算大，但逻辑和 Rust 类型系统的运用都足够复杂，我觉得够 AI 喝一壶的。 这期视频就是我对自己的怀疑进行的一次“证伪实验”——用 Claude Code 端到端地完成其中几项改动。我之前完全没亲自用过这类工具，只看过几支视频、几篇博文，所以这次是一手、二手体验的“无滤镜”首秀！我们最终搞定了四项任务里最简单的两项，然后 token 用光了 😅 整体过程既有趣又长见识。不过，它并未真正推翻我的怀疑；只能说，只要肯花时间“结对编程”，确实能走得很远。至于这类任务是否真的节省时间，我仍持保留意见。 Sguaba 的演示幻灯片放在 这儿。 【Luddite】:泛指对新技术或新趋势持强烈怀疑甚至抵制态度的人。源自 19 世纪英国工业革命兴起，机器开始大规模取代手工劳动，导致许多纺织工人失业。传说有一位名叫 内德·卢德（Ned Ludd） 的工人，愤怒之下砸毁了纺织机。于是，那些反对新技术、认为机器威胁生计的工人便被称为“卢德分子”。 观看：https://www.youtube.com/watch?v=EL7Au1tzNxE -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-08-02 文章《构建一个简单的哈希图》",
      "link": "https://rustcc.cn/article?id=b169cf3f-904d-439d-aa96-50343399ad7a",
      "description": "This Week in Rust #610 阅读：https://this-week-in-rust.org/blog/2025/07/30/this-week-in-rust-610/ 文章《构建一个简单的哈希图》 这篇文章介绍了如何用 Rust 语言从头构建一个简单的哈希表。哈希表是一种高效的数据结构，能够在平均 O(1) 的时间复杂度内完成插入和查询操作。 文章首先解释了哈希函数的作用，即通过将键映射为一个数字（哈希值）来快速定位键值对在内部存储中的位置。 接着，文章探讨了如何通过“桶”（buckets）来解决哈希冲突问题，即当不同键产生相同哈希值时的情况。 作者还介绍了如何通过动态调整桶的数量来保持哈希表的性能。文章最后提供了实现哈希表的 Rust 代码，包括插入、查询和扩容等关键功能，并通过测试验证了其正确性。 尽管这个哈希表实现相对简单，但它为理解哈希表的工作原理提供了一个很好的起点。 Reddit | 阅读：https://viniciusx.com/blog/building-a-hash-map/ Eon：简单且友好的配置格式 Eon 是一种简单易用的配置文件格式，旨在替代 Toml 和 YAML。 它使用 .eon 文件扩展名，语法类似于 JSON，但更简洁，支持任意类型的键值对和注释。 Eon 提供了强大的功能，如支持特殊浮点数（+inf、-inf、+nan）和命名的枚举变体。它还包含一个 Rust crate，支持与 Serde 集成，以及一个 eonfmt 工具，用于格式化 Eon 文件。Eon 的设计目标是简洁、易读、易写，适合人类手动编辑配置文件。示例： // Comment string: \"Hello Eon!\" list: [1, 2, 3] map: { boolean: true literal_string: 'Can contain \\ and \"quotes\"' } any_map: { 42: \"This key is an integer\" []: \"This key is an empty list\" } hex: 0xdead_beef special_numbers: [+inf, -inf, +nan] Reddit | 仓库：https://github.com/emilk/eon Grabapl： 基于图的编程语言框架和可视化平台 具有以下特点： 图状程序状态：程序的全部数据状态是一个有向图，包含节点和边的权重。 静态类型保证：支持用户定义静态类型的操作，确保运行时节点和边的存在及其类型正确性。 可插拔语义：允许客户端定义节点和边权重的类型系统、内置操作和查询。 增量式可视化操作定义：提供构建器以增量方式创建类型安全的用户定义操作，并支持任意前端。 可视化运行时执行追踪：支持通过快照追踪程序运行时执行，快照可可视化为图。 WebAssembly 支持：可编译为 WebAssembly。 在线 IDE：包含完整的在线 IDE，支持交互式图编辑器、操作状态可视化、运行时执行追踪可视化等。Playground Grabapl 旨在通过图结构和静态类型系统提供直观的编程体验，同时支持高度可定制的语义和可视化工具，便于开发和调试。 仓库：https://github.com/skius/grabapl cargo-license：查看依赖的 license 仓库：https://github.com/onur/cargo-license 讨论：serde_yaml 的替代 serde_yaml 被弃用，有没有其他库推荐使用？ “我用 serde_yaml 没问题。不更新又不是坏事。” “别用 serde_yml，那是低质量 AI 生成的库。” Reddit： https://www.reddit.com/r/rust/comments/1mbo9dl/alternative_for_serde_yaml/ https://www.reddit.com/r/rust/comments/1mbo9dl/comment/n5o1rqy/ -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-08-01 Pest Book 终章：实现 AWK 解析",
      "link": "https://rustcc.cn/article?id=5e237a11-3231-4fc0-b371-a2ce64db8aaa",
      "description": "Pest Book 终章：实现 AWK 解析 这个项目是一个基于 pest 解析器的 Awk 克隆实现，旨在提供一个完整的项目示例，展示如何使用 pest 解析器来解析和执行 Awk 脚本。 项目支持正则表达式模式、字符串和数值变量、大多数 POSIX 操作符和一些内置函数，但不支持用户定义函数以简化变量作用域管理。 AWK 是一种模式扫描和数据提取语言，擅长处理结构化文本文件。我们的实施将支持： 模式-动作编程模型 正则表达式匹配 处理 field 和 record 内置变量和函数 算术运算和字符串运算 控制流结构 在本教程结束时，您将拥有一个功能齐全的 AWK 解释器，能够运行以下程序： BEGIN { print \"Processing employee data...\" } /Engineer/ { engineers++ } $2 > 30 { print $1, \"is over 30 years old\" } END { print \"Found\", engineers, \"engineers\" } 阅读：https://pest.rs/book/examples/awk.html 代码：https://github.com/pest-parser/book/tree/master/examples/awk Rasterizeddb：在 115 毫秒内全表扫描 500 万行的高性能数据库 我用 Rust 从头开始编写的自定义数据库  Rasterized DB 能够在 115 毫秒内扫描 500 万行（全表扫描）。 它从无模式转变为有模式，兼容 PostgreSQL 方言，并计划引入多种高级特性。目前项目仍处于开发阶段，稳定性尚未成熟，建议谨慎使用。 Reddit | 仓库：https://github.com/milen-denev/rasterizeddb XMLity：功能最完善的 XML 解析库 XMLity 是一个受 Serde 启发的 XML 序列化/反序列化库，专为复杂 XML 结构设计，采用试错法解析，功能强大但速度稍慢。 它解决了其他库（如 yaserde、quick-xml）在命名空间和复杂结构支持上的不足。 与其他工具对比： serde-xml-rs：缺乏对命名空间和其他功能的完整支持。 yaserde：缺乏对试错法反序列化的支持，无法完整覆盖 XML 模式。 quick-xml：缺乏对命名空间的支持。 Reddit | 仓库：https://github.com/lukasfri/xmlity -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-07-31 2025 年 Stack Overflow 调查：Rust 再次成为最受推崇的语言；Axum 成为第二受推崇的 Web 框架",
      "link": "https://rustcc.cn/article?id=94572d44-4e58-4cae-baa2-28ac9f8b002d",
      "description": "Rust 再次成为 2025 年 Stack Overflow 调查中最受推崇的语言 Axum 是第二受推崇的 Web 框架！ 2025 SO Survey 结果：https://survey.stackoverflow.co/2025/technology/#admired-and-desired Reddit：https://www.reddit.com/r/rust/comments/1mcjdc9/once_again_rust_is_the_most_admired_language_in/ 文章《You Are The BIOS Now: Building A Hypervisor In Rust With KVM》 文章介绍了如何使用 Rust 和 KVM 构建一个 Type-II 虚拟机监控程序（hypervisor）。 作者通过直接操作 KVM 提供的接口，从用户态创建了一个虚拟 CPU（VCPU），并为其分配了内存。 接着，手动将 CPU 从实模式切换到长模式，设置了分页机制，初始化了通用寄存器，并编写了简单的机器代码作为虚拟机的启动代码。该代码通过 I/O 端口输出字符，实现了简单的“Hello, World!”功能。 整个过程涉及大量底层操作，包括内存映射、分页表设置、全局描述符表（GDT）配置等，展示了在 Rust 中进行系统编程的复杂性和挑战性。 Reddit | 阅读：https://www.reddit.com/r/rust/comments/1mcfao9/you_are_the_bios_now_building_a_hypervisor_in/ Rig：轻量级、可组合智能代理创建的代理型 AI 框架 通常我不会在这里发布 Rig 的版本更新，因为 Reddit 上对 AI 相关内容的接受度通常较低。然而，这次更新意义重大，因为它不仅标志着 rig-wasm（通过 WASM 和一些 TS 胶水代码实现的实验性 Rig JS 移植）的发布，还新增了几个我认为在该库的整个生命周期内都将保持稳定的比较重要的功能： VectorSearchIndex 函数现在接受 VectorSearchRequest，而非查询和样本大小（即返回结果的数量），这意味着它未来将更具可扩展性。VectorSearchRequest 也提供了构建器。 现在正式支持思考和推理功能。从响应中解析思考块还有很长的路要走，但对于模型提供者预先解析的结果，它们是受支持的。 完成流现在将使用情况作为流项返回，而不仅仅是最终结果。 每个模型提供者现在都有一个构建器了——特别感谢 Sytten 的慷慨贡献。 我们还为 Extractor 添加了一些额外的追踪功能，如果内层的 Submit 工具从未被调用，它会告知你，并且如果你多次遇到该问题，它会提示你升级到一个能更可靠地调用工具的模型。 未来版本的计划内容： 为向量搜索添加相似性搜索阈值 提示钩子（例如在提示前后、工具调用等环节插入你自己的函数） 总体可观测性升级，能够为代理命名 A2A（代理到代理通信） 仓库：https://github.com/0xPlaygrounds/rig Hurl：发布 7.0.0 Hurl 是一个开源命令行工具，允许用户通过纯文本格式运行和测试 HTTP 请求。 它适用于获取数据或在 CI/CD 流水线中测试 HTTP API（包括 JSON、GraphQL 和 SOAP）。以下是 Hurl 7.0.0 版本的核心内容总结： 功能特点： 纯文本格式：使用简单的纯文本格式定义 HTTP 请求。 请求链式调用：可以将多个请求链接起来，方便复杂场景的测试。 捕获与断言：支持从响应中捕获值，并对响应头、状态码、正文内容等进行断言。 支持多种 API：适用于 HTML、REST、SOAP、GraphQL 等多种 API。 性能测试：可以测试 HTTP 端点的响应时间。 CI/CD 集成：支持生成多种格式的测试报告（如 JUnit、TAP、HTML）。 技术实现： 底层引擎：Hurl 使用了 Rust 编写的 curl-rust 绑定，基于强大的 curl 库。 性能优势：继承了 curl 的高效性和对 HTTP/3 的支持。 新版本更新内容： 增强的重定向检查：新增更多方式来检查重定向的每个步骤。 模板化请求和响应：新增过滤器，支持对 HTTP 请求和响应进行模板化。 支持更多 curl 选项：新增对更多 curl 命令行选项的支持。 基本使用示例： GET https://example.org/api/tests/4567 HTTP 200 [Asserts] jsonpath \"$.status\" == \"RUNNING\"    # 检查状态码 jsonpath \"$.tests\" count == 25      # 检查项目数量 jsonpath \"$.id\" matches /\\d{4}/     # 检查 ID 格式 header \"x-foo\" contains \"bar\"       # 检查响应头 certificate \"Expire-Date\" daysAfterNow > 15  # 检查证书过期时间 ip == \"2001:0db8:85a3:0000:0000:8a2e:0370:733\"  # 检查 IP 地址 文档：https://hurl.dev 仓库：https://github.com/Orange-OpenSource/hurl -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-07-30 通过 JOP/ROP 使用混淆的返回地址进行间接系统调用",
      "link": "https://rustcc.cn/article?id=1f6e21c0-0269-47d0-b3cd-b375b09c928f",
      "description": "文章《Dynamic Indirect Syscalls via JOP or ROP in Rust》 no_std、no_alloc、无依赖的 Rust 库：通过 JOP/ROP 使用混淆的返回地址进行间接系统调用 这篇文章介绍了一个用 Rust 编写的项目，旨在通过 JOP（Jump-Oriented Programming）或 ROP（Return-Oriented Programming）技术动态间接调用 Windows 系统调用，以绕过检测机制。 项目的核心思想是通过用户提供的 ROP/JOP 链在运行时动态计算出调用路径，使得分析系统调用的来源更加困难。 作者通过构造一个包含 jmp rcx、pop rcx; ret 等指令的 gadget 链，实现了对系统调用的间接调用。项目还支持动态调用 WinAPI 和非 ROP/JOP 系统调用，并提供了 API 哈希功能以进一步隐藏调用。 尽管该库目前不稳定且存在限制（如仅支持 x64 和 Windows），但其理论和实现为恶意软件开发和安全研究提供了新的思路。 阅读：https://kirchware.com/Dynamic-Indirect-Syscalls-via-JOP-or-ROP-in-Rust Reddit  | 仓库 Orx-parallel：高性能、可配置的并行计算库 orx-parallel 是一个高性能、可配置的并行计算库，专注于通过迭代器方法组合定义的计算任务。 它通过 ParIter 特性实现并行计算，目标是让用户只需将 iter 替换为 par，即可将顺序程序高效并行化。 该库支持多种并行化方式：直接并行化集合（如 Vec 和 VecDeque）、将任意迭代器并行化，以及通过中间集合（如 Vec）并行化其他集合。 它还提供了丰富的配置选项，如线程数和块大小，并通过锁无关的并发迭代器和线程安全容器实现高效的并行输入和输出。 根据其基准测试结果，比 rayon 快： 仓库：https://github.com/orxfun/orx-parallel Reddit：https://www.reddit.com/r/rust/comments/1mapoqv/crates_you_should_know_orxparallel_as_faster/ Fast_assert：更快的断言宏，标准库中的 assert! 替代 fast_assert! 是一个为 Rust 编写的更快的断言宏，旨在替代标准库中的 assert!。 它通过将断言失败时的处理逻辑（如格式化错误信息）推迟到标注为 #[cold] 的单独函数中，从而减少热代码路径中的指令数量。 与标准库的 assert! 相比，fast_assert! 在默认错误消息时仅增加两条指令，在自定义错误消息时增加三条指令，而标准库的 assert! 在默认错误消息时增加五条指令，在自定义错误消息时增加更多指令。这种优化减少了指令缓存压力，可能使编译器能够更积极地内联热函数。 该库的实现方式是通过闭包将所有参数格式化推迟到冷函数中，这与标准库的 assert! 在大多数情况下表现相同，但在某些边缘情况下可能会有所不同。因此，这种改进可能不适用于标准库，除非在新的语言版本中引入。 仓库：https://github.com/Shnatsel/fast_assert Reddit：https://www.reddit.com/r/rust/comments/1mao817/announcing_fast_assert_its_assert_but_faster/ -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "【Rust日报】2025-07-29 在 Rust 中使用 ndarray 和 opencv 处理图像",
      "link": "https://rustcc.cn/article?id=8942a1f0-7047-4307-82a4-ba4e2b61343a",
      "description": "文章《Using OpenCV and NdArray in Rust》 这篇文章介绍了在 Rust 中混合使用 ndarray 和 opencv 两个库进行图像处理的技术。 ndarray 提供了类似 NumPy 的多维数组和数学运算功能，而 opencv 提供了 OpenCV 的 Rust API。文章指出，尽管 opencv 提供了 Mat 类型用于存储图像数据，但使用 ndarray::Array 更为方便，因为 Mat 的维度和数据类型不是其类型签名的一部分，容易导致混淆。此外，ndarray 提供了更多数值处理功能。 文章详细描述了如何在 Rust 中实现 Mat 和 ndarray::Array 之间的转换，包括从 Mat 转换为 Array（需要复制数据）和从 Array 转换为 Mat（可以零拷贝）。通过 BoxedRef 和 BoxedRefMut，可以安全地管理这些转换的生命周期。文章还提供了一个示例，展示了如何在 Rust 中实现类似 Python 的图像处理流程，包括读取图像、应用数值操作并保存结果。 阅读：https://forgestream.idverse.com/blog/20250728-opencv-and-ndarray/ Sniffnet 成立 3 周年 Sniffnet 是一款开源的网络分析工具，用于监控和分析网络连接。它能够帮助用户识别网络中的活动，是系统管理员和网络安全专家的有力工具。 今天迎来了三周年纪念。过去一年，Sniffnet 从玩具应用成长为成熟软件，发布了 v1.3.2 和 v1.4.0 版本，还搭建了博客、完善文档、推出周边，并制定了详细路线图。未来将加入进程识别功能，进一步提升网络监控能力。社区反馈和下载量持续增长，推动了 Sniffnet 的发展。项目通过欧盟 Next Generation Internet 计划获得资金支持，未来将继续探索可持续发展路径。 阅读：https://sniffnet.net/news/third-anniversary/ Git-cliff：发布  2.10.0 git-cliff 是一个高度可定制的命令行工具，用于从 Git 历史记录中生成变更日志（Changelog）。它遵循常规的 Commit 规范，支持通过正则表达式自定义解析规则。 git-cliff 可以根据提交记录自动生成结构化的变更日志文件，支持多种配置选项和模板，以满足不同项目的需求。此外，它还支持多仓库变更日志聚合，并可通过配置文件高度定制输出格式。 新增功能包括： 发布统计信息：支持在变更日志中添加发布相关指标，如提交数量、首次和最后一次提交的时间跨度、遵循规范的提交数量等。 新模板：新增 statistics.toml 模板，方便用户快速生成包含统计信息的变更日志。 路径过滤：支持在配置文件中通过 include_paths 和 exclude_paths 选项包含或排除特定路径。 数组匹配支持：提交解析器支持对数组值（如 GitHub 标签）进行正则匹配。 Gentoo 支持：git-cliff 已加入 Gentoo Linux 软件包仓库。 代码风格改进：代码库统一使用空格代替制表符，更符合 Rust 社区规范。 阅读：https://git-cliff.org/blog/2.10.0/ The Cheese Chase：使用 Rust + Macroquad 开发的街机游戏 刚刚完成了我的第一款游戏《奶酪追逐》！🧀🐭 使用 Rust + Macroquad 开发。 这是一款简单的街机游戏，你扮演一只老鼠，一边收集奶酪，一边躲避驱鼠剂。 最初我使用 SDL2 开发，但在编译到 WASM 时遇到了问题，所以我改用了 Macroquad，这使得网络部署变得轻松多了。 操作很简单，只需要使用左右箭头键，但游戏难度可不小，相当有挑战性！ 网址：https://sattva9.itch.io/the-cheese-chase -- From 日报小组 苦瓜小仔 社区学习交流平台订阅： Rustcc论坛: 支持rss 微信公众号：Rust语言中文社区",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "2025·秋季 【Rust 编译器训练营】｜重磅来袭！| 开源免费",
      "link": "https://rustcc.cn/article?id=649caf46-48aa-497d-9d9a-8c84ce2eb0c8",
      "description": "2025 秋季 Rust 编译器训练营 · 首期招生开启！ 这是继用 Rust 写操作系统之后，国内首个、也是目前唯一一个“用 Rust 写编译器”的重量级系统软件训练营！由南京大学 × 中国科学院软件研究所联合发起，华为全程赞助，18 周带你从 0 到 1 深入 rustc 源码，成为能向官方提交 PR 的编译器贡献者。 ⏰ 时间：2025/8/4 – 12/20 🏕️ 平台：「OpenCamp 训练营平台」 四阶段进阶路线 1️⃣ Rust 基础极速热身 2️⃣ 编译器原理硬核拆解 3️⃣ rustc 架构深度剖析 4️⃣ 真实 Issue 实战 & 上游贡献 你将收获 官方认证结业证书 直接向 Rust 官方仓库提交 PR 的机会 华为/南大/ISRC 实习绿色通道 第一次，用 Rust 写世界级编译器——就从你这一行代码开始。 报名链接： https://opencamp.cn/rustcompiler/camp/2025fall/register?code=cFYDt2lDDaeyX 公众号文章",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "Senior Rust Developer / 高级 Rust 开发工程师，Onsite -Singapore （ Local or PR ）",
      "link": "https://rustcc.cn/article?id=f76cc84c-6a3f-486f-a925-cd21f26a90d8",
      "description": "Senior Rust Developer / 高级 Rust 开发工程师 Salary：SGD 6,000 – 15,000 Base: Onsite -Singapore （ Local or PR ） Responsibilities / 岗位职责 Responsible for the architecture design and R&D of the company’s core platform services using Rust. 使用 Rust 语言负责公司核心平台服务的架构设计与研发工作。 Continuously deliver reliable, efficient, and cost-effective data services that create business value. 持续交付稳定、高效、具备成本优势的数据服务，为业务创造价值。 Provide architectural and performance optimization solutions, and drive fast iterations of backend systems. 提供系统架构与性能优化方案，推动后端服务的快速迭代。 Collaborate closely with product and infrastructure teams to ensure high availability, scalability, and observability. 与产品及基础设施团队密切协作，确保系统具备高可用性、可扩展性与可观测性。 ⸻ Requirements / 任职要求 Proficient in Rust, with experience in building production-grade backend or systems-level applications. 精通 Rust 编程语言，具备上线系统/后端服务的开发经验。 Solid foundation in computer science: operating systems, networking, algorithms, concurrency, and data structures. 具备扎实的计算机基础知识，掌握操作系统、网络、并发编程、常用算法与数据结构。 Degree in Computer Science, Engineering, Mathematics, or related fields. 计算机、工程、数学或相关专业本科及以上学历。 Experience designing and developing distributed systems or microservice architectures, with a focus on high availability and scalability. 有分布式系统或微服务架构的设计与开发经验，注重系统的高可用性与可扩展性。 Familiar with async runtimes (e.g., Tokio, async-std) and the Rust ecosystem (e.g., Actix, Axum, Serde, Cargo). 熟悉 Rust 异步运行时（如 Tokio 、async-std ）及相关生态工具（如 Actix 、Axum 、Serde 、Cargo ）。 Hands-on experience with caching (e.g., Redis), messaging systems (e.g., Kafka), and data streaming (e.g., Flink or equivalents). 熟悉缓存系统（如 Redis ）、消息队列（如 Kafka ）与数据流处理框架（如 Flink 或同类工具）。 Experience with performance profiling, observability, and system reliability best practices. 具备性能分析、系统可观测性及稳定性保障的实践经验。 Strong ownership mindset, with a passion for writing clean, efficient, and maintainable code. 具备强烈的责任心与工程精神，追求简洁、高效、可维护的代码风格。 请携带简历咨询，谢谢。",
      "pub_date": null,
      "source": "Rust中文社区"
    },
    {
      "title": "截图工具 - 功能丰富的Windows原生截图应用",
      "link": "https://rustcc.cn/article?id=ff36b374-bc16-43d6-9924-40d6c858723a",
      "description": "截图工具 - 功能丰富的Windows原生截图应用 项目概述 这是一个使用Rust开发的Windows原生截图工具，集成了截图、标注、OCR文字识别等多项功能。项目采用Windows API和Direct2D进行高性能图形渲染，提供流畅的用户体验。 仓库地址: https://github.com/han1548772930/sc_windows 核心功能 📸 智能截图 全屏/区域截图: 支持全屏截图和鼠标拖拽选择任意区域 窗口检测: 自动识别并高亮窗口边界 实时预览: 截图过程中实时显示选择区域 🎨 绘图标注 多种工具: 矩形、圆形、箭头、自由画笔、文字标注 自定义样式: 支持颜色选择、线条粗细调节 撤销功能: 支持操作撤销 🔍 OCR文字识别 PaddleOCR集成: 基于PaddleOCR引擎的高精度文字识别 多语言支持: 支持中文(简/繁)、英文、日文、韩文 异步处理: OCR引擎异步启动，不阻塞界面操作 智能状态管理: 按钮状态根据引擎可用性自动更新 📌 便捷功能 固钉窗口: 将截图固定在桌面，支持拖拽移动 快速保存: 一键保存到剪贴板或文件 系统集成: 系统托盘运行，全局热键Ctrl+Alt+S快速启动 技术特色 Rust语言: 内存安全，性能优异 Windows原生: 直接调用Windows API，系统集成度高 Direct2D渲染: 高性能图形渲染 模块化设计: 清晰的代码结构，易于维护和扩展 项目结构 截图工具/ ├── sc_windows.exe                    # 主程序 ├── PaddleOCR-json_v1.4.exe/        # OCR引擎文件夹 └── README.md                        # 说明文档 快速使用 启动: 运行程序后自动最小化到系统托盘 截图: 使用Ctrl+Alt+S热键或点击托盘图标 标注: 使用工具栏进行绘图标注 OCR: 点击OCR按钮识别图片中的文字 保存: 保存到剪贴板、文件或固定到桌面 这个项目展示了Rust在Windows桌面应用开发中的强大能力，通过原生API调用实现了专业级的截图工具功能。",
      "pub_date": null,
      "source": "Rust中文社区"
    }
  ],
  "summary": "今日 Rust 技术动态聚焦工业应用与语言特性探讨：三菱 MC 协议 3E 帧的 Rust 实现展示了在工业自动化领域的应用潜力，同时关于隐式 auto-trait bounds 的深度讨论揭示了语言设计的复杂性。值得关注的是，2025 Stack Overflow 调查显示 Rust 连续蝉联\"最受推崇语言\"，Axum 框架也跃居 Web 领域第二位，印证了 Rust 生态的持续繁荣。\n\ntokio-mc：Rust 实现三菱 PLC MC 协议通信\n--------------\n\n### 项目目标和解决的问题\n该项目旨在为工业自动化领域提供一个高性能、可扩展的 PLC 通信库，填补 Rust 生态在三菱 MC 协议实现方面的空白。主要解决工业控制系统中设备通信的跨平台、跨语言需求，特别针对三菱和 Keyence PLC 的二进制 3E 帧通信协议。\n\n### 主要功能特点\n* 支持三菱 3E 协议二进制格式通信\n* 提供 bit/word 数据的读写操作\n* 基于 tokio 的异步通信实现\n* 兼容 Keyence 和 Mitsubishi PLC\n* 内置模拟服务器用于测试\n* 模块化架构设计，参考 tokio-modbus\n\n### 技术特色和创新点\n1. **通信协议解耦**：采用可插拔的编码器/解码器设计，便于扩展其他协议\n2. **寄存器地址抽象**：提供统一的地址封装接口\n3. **跨平台支持**：计划通过 FFI 提供 Python/C#/C++ 调用接口\n4. **异步架构**：基于 tokio 实现高性能异步通信\n\n### 使用示例\n```rust\nuse tokio_mc::{client::tcp::*, frame::Model};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut context = connect(\"127.0.0.1:5000\".parse()?).await?;\n    context.set_plc_model(Model::Mitsubishi); // or Model::Keyence\n    \n    // 写入 word 数据\n    context.write_u8s(\"D100\", &[0x12, 0x34]).await?;\n    \n    // 读取 bit 状态\n    let bits = context.read_bits(\"M0\", 8).await?;\n    println!(\"Bits: {:?}\", bits);\n    Ok(())\n}\n```\n\n### 与现有方案的对比\n相比现有的 Modbus 实现，该项目：\n1. 专注三菱专有协议，填补 Rust 生态空白\n2. 提供更贴近 PLC 原生特性的操作接口\n3. 设计上更注重可扩展性，便于支持其他品牌 PLC\n4. 计划提供多语言支持，比纯 Rust 实现更具通用性\n\n### 未来发展路线\n* 支持松下 PLC 通信适配\n* 扩展 ASCII 格式帧支持\n* 完善 FFI 接口（Python/C#/C++）\n* 增强协议兼容性和错误处理\n\n仓库：[GitHub](https://github.com/tokio-mc) | 讨论：[Rust中文社区](https://rustcc.cn/article?id=82c96c43-4d6a-4fd0-8656-e3b20c1ce9c3)\n\n文章《添加隐式 auto-trait bounds 很困难》\n--------------\n\n本文由 Rust 类型团队负责人 lcnr 撰写，深入探讨了在 Rust 中添加隐式自动特征边界的技术挑战和权衡取舍。\n\n### 主要内容和技术要点\n- 分析了添加隐式自动特征边界（如 Leak、Moveable 和 MetaSized）的潜在好处\n- 揭示了这类修改带来的显著性能成本，特别是对编译时间的影响\n- 通过具体案例说明：为 TyCtxt 添加自动特征导致编译时间从 7 分钟延长到 33 分钟\n\n### 核心实现细节\n- 性能问题主要源于自动特征实现不局限于指针间接层\n- 编译器需要处理的特征检查复杂度呈指数级增长\n- 即使进行优化也无法完全避免性能退化\n\n### 技术挑战\n1. 需要增加递归限制来处理复杂的特征约束\n2. 可能触发错误的协程生命周期错误\n3. 特征系统的扩展性与编译器性能之间的根本矛盾\n\n### 实际价值\n- 为语言设计者提供了重要的性能权衡参考\n- 帮助开发者理解 Rust 特征系统的内部工作机制\n- 对编译器优化方向提供了有价值的实证数据\n\n### 对 Rust 生态的意义\n- 展示了语言演进过程中面临的深层次技术挑战\n- 强调了编译器性能在语言设计决策中的关键作用\n- 为未来特征系统的改进提供了技术基准\n\n[Reddit] | 阅读：[原文链接](https://lcnr.de/blog/2025/07/28/implicit-auto-trait-bounds.html)\n\n根据提供的新闻内容，我将分别对每个部分生成详细的技术摘要：\n\n### This Week in Rust #610\n----------------------\n\n阅读：[https://this-week-in-rust.org/blog/2025/07/30/this-week-in-rust-610/](https://this-week-in-rust.org/blog/2025/07/30/this-week-in-rust-610/)\n\n### 文章《构建一个简单的哈希图》\n--------------\n\n- **主要内容**：详细讲解如何用Rust从头实现一个基础哈希表数据结构，涵盖从理论到实践的全过程\n- **技术要点**：\n  - 哈希函数实现：将键转换为数值索引的核心算法\n  - 冲突处理：采用链地址法(separate chaining)解决哈希碰撞\n  - 动态扩容：当负载因子超过阈值时自动调整存储容量\n- **实现细节**：\n  - 使用Vec作为底层存储容器\n  - 通过Entry API提供高效的插入/查询接口\n  - 包含完整的测试用例验证正确性\n- **实用价值**：帮助开发者深入理解标准库HashMap的工作原理，适合需要自定义哈希行为的场景\n- **生态意义**：展示了Rust在系统编程领域实现基础数据结构的优势\n\n[Reddit] | 阅读：[https://viniciusx.com/blog/building-a-hash-map/](https://viniciusx.com/blog/building-a-hash-map/)\n\n### Eon：简单且友好的配置格式\n--------------\n\n- **项目目标**：提供比TOML/YAML更简洁易用的配置文件格式\n- **核心特性**：\n  * 类似JSON但更简洁的语法\n  * 支持任意类型键值对（包括非字符串键）\n  * 完整的注释支持\n  * 特殊数值处理（Infinity/NaN）\n- **技术亮点**：\n  - 与Serde无缝集成\n  - 提供格式化工具(eonfmt)\n  - 严格的解析器实现\n- **对比优势**：\n  - 比TOML更灵活的类型系统\n  - 比YAML更简单的语法和更可预测的行为\n- **示例场景**：适用于需要人工编辑的复杂配置文件\n\n[Reddit] | 仓库：[https://github.com/emilk/eon](https://github.com/emilk/eon)\n\n### Grabapl：基于图的编程语言框架\n--------------\n\n- **创新架构**：将有向图作为核心程序表示形式\n- **关键技术**：\n  * 静态类型化的图节点和边\n  * 可扩展的类型系统和操作语义\n  * 增量式操作定义\n- **可视化能力**：\n  - 实时图结构编辑\n  - 执行过程追踪\n  - WebAssembly支持\n- **应用场景**：\n  - 可视化编程工具开发\n  - 复杂数据流处理\n  - 教学和研究用途\n- **生态定位**：填补了Rust生态中高级可视化编程框架的空白\n\n仓库：[https://github.com/skius/grabapl](https://github.com/skius/grabapl)\n\n### cargo-license：依赖许可证检查工具\n--------------\n\n仓库：[https://github.com/onur/cargo-license](https://github.com/onur/cargo-license)\n\n### 讨论：serde_yaml的替代方案\n-----------------\n\n- **讨论背景**：serde_yaml维护状态引发社区寻找替代方案\n- **核心观点**：\n  - 部分用户认为稳定库无需频繁更新\n  - 对替代库质量的担忧\n- **技术建议**：\n  - 评估现有实现是否满足需求\n  - 谨慎选择未经充分验证的新库\n- **引用观点**：\n  \"别用serde_yml，那是低质量AI生成的库。\"\n\nReddit：[https://www.reddit.com/r/rust/comments/1mbo9dl/alternative_for_serde_yaml/](https://www.reddit.com/r/rust/comments/1mbo9dl/alternative_for_serde_yaml/)\n\n## 项目/工具摘要\n\n### Pest Book 终章：实现 AWK 解析\n--------------\n\n**项目介绍：**\n这是一个基于 pest 解析器的 AWK 语言实现项目，作为 pest 官方文档的终章示例。该项目完整展示了如何使用 pest 解析器构建一个脚本语言的解析器和解释器。\n\n**技术细节：**\n* 实现了 AWK 核心功能：\n  - 模式-动作编程模型\n  - 正则表达式匹配\n  - 字段(Field)和记录(Record)处理\n  - 内置变量和函数\n  - 算术和字符串运算\n  - 控制流结构\n* 简化实现：\n  - 省略了用户定义函数以简化变量作用域管理\n  - 支持大多数 POSIX 操作符\n\n**示例代码：**\n```awk\nBEGIN { print \"Processing employee data...\" }\n/Engineer/ { engineers++ }\n$2 > 30 { print $1, \"is over 30 years old\" }\nEND { print \"Found\", engineers, \"engineers\" }\n```\n\n**学习价值：**\n- 展示了如何用 pest 构建完整语言解释器\n- 演示了词法分析、语法分析和解释执行的完整流程\n- 可作为学习编译原理和语言实现的优秀案例\n\n阅读：[教程链接](https://pest.rs/book/examples/awk.html) | \n仓库：[GitHub](https://github.com/pest-parser/book/tree/master/examples/awk)\n\n---\n\n### Rasterizeddb：高性能数据库\n--------------\n\n**项目介绍：**\n一个用 Rust 从头实现的高性能数据库，专注于极速全表扫描能力。\n\n**技术亮点：**\n* 性能表现：\n  - 115ms 内完成 500 万行全表扫描\n* 架构演进：\n  - 从无模式设计转为有模式设计\n  - 兼容 PostgreSQL 方言\n* 开发路线：\n  - 计划引入多种高级特性\n  - 目前仍处于开发阶段，稳定性待验证\n\n**适用场景：**\n- 需要快速全表扫描的分析型应用\n- 对 PostgreSQL 兼容性有要求的场景\n\n**注意事项：**\n项目尚不成熟，生产环境需谨慎评估。\n\nReddit | 仓库：[GitHub](https://github.com/milen-denev/rasterizeddb)\n\n---\n\n### XMLity：功能完善的 XML 解析库\n--------------\n\n**项目介绍：**\n一个受 Serde 启发的 XML 处理库，专注于处理复杂 XML 结构。\n\n**技术特点：**\n* 创新解析方法：\n  - 采用试错法解析策略\n  - 牺牲部分速度换取更强的容错能力\n* 功能优势：\n  - 完整支持 XML 命名空间\n  - 能处理复杂嵌套结构\n* 与其他库对比：\n  - 相比 serde-xml-rs：功能更完整\n  - 相比 yaserde：支持试错法反序列化\n  - 相比 quick-xml：支持命名空间\n\n**适用场景：**\n- 需要处理复杂 XML 文档的应用\n- 对 XML 规范兼容性要求高的场景\n\nReddit | 仓库：[GitHub](https://github.com/lukasfri/xmlity)\n\n### 对于技术文章:\n文章《You Are The BIOS Now: Building A Hypervisor In Rust With KVM》\n--------------\n\n这篇文章详细介绍了如何使用 Rust 和 KVM (Kernel-based Virtual Machine) 构建一个 Type-II 虚拟机监控程序(hypervisor)。主要技术内容包括：\n\n- **KVM 接口操作**：作者直接使用 KVM 提供的用户态接口创建虚拟 CPU (VCPU) 并分配内存\n- **CPU 模式切换**：手动将 CPU 从实模式(real mode)切换到长模式(long mode)\n- **内存管理**：设置分页机制和全局描述符表(GDT)\n- **虚拟机启动**：编写简单的机器代码作为虚拟机启动代码，通过 I/O 端口输出\"Hello, World!\"\n\n技术亮点：\n* 展示了 Rust 在系统编程中的能力，包括直接操作硬件资源\n* 详细解释了虚拟化技术的底层实现细节\n* 演示了从零开始构建 hypervisor 的完整流程\n\n适用场景：\n- 系统编程学习\n- 虚拟化技术研究\n- 操作系统开发\n- 安全研究(如沙箱实现)\n\n对 Rust 生态的意义：\n展示了 Rust 在底层系统编程领域的强大能力，特别是在需要安全性和性能并重的场景。\n\n[Reddit] | 阅读：[原文链接]\n\n### 对于项目/工具:\nRig：轻量级、可组合智能代理创建的代理型 AI 框架\n--------------\n\nRig 是一个用于创建智能代理的框架，最新版本带来了重要更新：\n\n项目目标：\n* 提供轻量级、可组合的智能代理开发方案\n* 支持通过 WASM 实现跨平台部署\n\n主要更新：\n* 新增 rig-wasm：实验性的 WASM 移植版本\n* 改进 VectorSearchIndex 函数，使用更灵活的 VectorSearchRequest\n* 正式支持思考和推理功能\n* 完善完成流(completion stream)功能\n* 为所有模型提供者添加构建器支持\n* 增强 Extractor 的追踪功能\n\n技术特色：\n* 采用 Rust 实现核心功能\n* 通过 WASM 实现跨平台能力\n* 提供更可靠的错误提示机制\n\n未来计划：\n* 相似性搜索阈值\n* 提示钩子功能\n* 代理命名支持\n* 代理间通信(A2A)功能\n\n[Reddit] | 仓库：[GitHub链接]\n\n### 对于项目/工具:\nHurl：发布 7.0.0\n--------------\n\nHurl 是一个用 Rust 编写的命令行 HTTP 请求测试工具：\n\n项目目标：\n* 提供简单的方式测试 HTTP API\n* 支持 CI/CD 集成\n\n核心功能：\n* 纯文本格式定义请求\n* 请求链式调用\n* 响应捕获和断言\n* 支持多种 API 类型(REST, GraphQL, SOAP等)\n* 性能测试\n* 多种报告格式输出\n\n技术实现：\n* 基于 curl-rust 绑定\n* 支持 HTTP/3\n* 高性能\n\n7.0.0 更新：\n* 增强重定向检查\n* 新增请求/响应模板功能\n* 支持更多 curl 选项\n\n使用示例：\n```\nGET https://example.org/api/tests/4567\nHTTP 200\n[Asserts]\njsonpath \"$.status\" == \"RUNNING\"\njsonpath \"$.tests\" count == 25\nheader \"x-foo\" contains \"bar\"\n```\n\n文档：https://hurl.dev\n仓库：https://github.com/Orange-OpenSource/hurl\n\n### 社区动态：\n2025 年 Stack Overflow 调查结果\n-----------------\n\n主要发现：\n* Rust 连续多年成为最受推崇的编程语言\n* Axum 框架成为第二受推崇的 Web 框架\n\n重要观点：\n\"Rust 的持续领先地位证明了其在开发者社区中的高度认可，特别是在系统编程领域。Axum 的崛起也反映了 Rust 在 Web 开发领域的成熟。\"\n\n调查链接：https://survey.stackoverflow.co/2025/technology/#admired-and-desired\nReddit 讨论：https://www.reddit.com/r/rust/comments/1mcjdc9/once_again_rust_is_the_most_admired_language_in/\n\n我将为这条新闻中的三个项目分别生成详细的技术摘要：\n\n### 技术文章《Dynamic Indirect Syscalls via JOP or ROP in Rust》\n--------------\n\n这篇文章介绍了一个创新的Rust安全研究项目，主要技术要点包括：\n\n- 核心机制：使用JOP(跳转导向编程)和ROP(返回导向编程)技术实现动态间接系统调用\n- 技术实现：\n  * 通过用户提供的ROP/JOP链在运行时动态计算调用路径\n  * 使用`jmp rcx`、`pop rcx; ret`等指令构造gadget链\n  * 支持动态调用WinAPI和非ROP/JOP系统调用\n  * 提供API哈希功能增强隐蔽性\n\n- 项目特点：\n  * 纯Rust实现，无标准库依赖(no_std)\n  * 无内存分配依赖(no_alloc)\n  * 专注于绕过现代安全检测机制\n\n- 当前限制：\n  * 仅支持x64架构和Windows系统\n  * 项目仍处于不稳定阶段\n\n该研究为恶意软件分析和防御技术研究提供了新的思路，展示了Rust在底层系统编程和安全研究领域的潜力。\n\n[Reddit] | 阅读：[原文链接](https://kirchware.com/Dynamic-Indirect-Syscalls-via-JOP-or-ROP-in-Rust)\n\n### 项目：orx-parallel - 高性能可配置并行计算库\n--------------\n\norx-parallel是一个专注于迭代器并行化的高性能Rust库：\n\n- 项目目标：\n  * 提供简单高效的并行计算方案\n  * 通过最小代码修改实现顺序程序并行化\n\n- 主要特性：\n  * 通过`ParIter`特性实现并行迭代\n  * 支持三种并行化模式：\n    - 直接并行化集合(Vec/VecDeque)\n    - 任意迭代器并行化\n    - 通过中间集合并行化\n  * 丰富的配置选项：\n    - 线程数控制\n    - 任务块大小调整\n\n- 技术优势：\n  * 使用锁无关的并发迭代器\n  * 线程安全容器实现高效I/O\n  * 基准测试显示性能优于Rayon\n\n该库特别适合需要精细控制并行计算参数的高性能计算场景。\n\n[Reddit](https://www.reddit.com/r/rust/comments/1mapoqv/crates_you_should_know_orxparallel_as_faster/) | 仓库：[GitHub](https://github.com/orxfun/orx-parallel)\n\n### 项目：fast_assert - 更快的断言宏\n--------------\n\nfast_assert是针对Rust标准库assert!宏的性能优化替代方案：\n\n- 优化原理：\n  * 将错误处理逻辑推迟到`#[cold]`标记函数\n  * 减少热代码路径指令数量\n\n- 性能对比：\n  * 默认错误消息：仅增加2条指令(标准库增加5条)\n  * 自定义错误消息：增加3条指令(标准库增加更多)\n\n- 实现细节：\n  * 使用闭包延迟参数格式化\n  * 减少指令缓存压力\n  * 可能提升函数内联机会\n\n- 适用场景：\n  * 性能关键代码中的频繁断言\n  * 需要最小化指令数的场景\n\n该库展示了Rust宏系统在性能优化方面的潜力，但作者指出这种改变可能更适合在语言新版本中引入。\n\n[Reddit](https://www.reddit.com/r/rust/comments/1mao817/announcing_fast_assert_its_assert_but_faster/) | 仓库：[GitHub](https://github.com/Shnatsel/fast_assert)\n\n文章《Using OpenCV and NdArray in Rust》\n--------------\n\n这篇文章深入探讨了在Rust中结合使用ndarray和opencv两个库进行图像处理的技术方案。\n\n主要技术要点：\n- 对比了opencv的Mat类型和ndarray::Array的差异：Mat类型在类型签名中不包含维度和数据类型信息，容易导致混淆，而ndarray提供了更明确的类型系统和丰富的数值处理功能\n- 详细分析了两种数据结构间的转换机制：\n  * 从Mat到Array需要数据拷贝，但能获得更友好的数值处理接口\n  * 从Array到Mat可实现零拷贝转换，通过BoxedRef/BoxedRefMut管理生命周期\n- 介绍了Rust中实现类似Python图像处理工作流的方法\n\n核心实现细节：\n1. 使用opencv::imgcodecs::imread读取图像到Mat\n2. 通过Mat::data()获取原始指针，结合ArrayView构建ndarray视图\n3. 应用ndarray的数值运算（如矩阵运算、广播等）\n4. 使用Array::as_slice_memory_order()获取连续内存视图\n5. 通过Mat::new_rows_cols_with_data创建新的Mat对象\n\n实际应用价值：\n- 为Rust开发者提供了Python+NumPy+OpenCV工作流的替代方案\n- 结合了OpenCV的图像I/O能力和ndarray的数值计算优势\n- 特别适合需要高性能数值处理的计算机视觉应用\n\n对Rust生态的意义：\n- 填补了Rust在科学计算和图像处理交叉领域的空白\n- 展示了不同生态库之间的互操作可能性\n- 为科学计算领域的Rust采用提供了实用参考\n\n[Reddit] | 阅读：[原文链接](https://forgestream.idverse.com/blog/20250728-opencv-and-ndarray/)\n\n### 对于项目/工具:\n2025·秋季 Rust 编译器训练营：国内首个 Rust 编译器开发实战训练项目\n--------------\n\n[项目详细介绍：]\n- **项目目标**：培养能够深入理解并贡献 Rust 编译器的开发者，填补国内 Rust 系统级人才培养空白\n- **核心特色**：\n  * 由南京大学和中国科学院软件研究所联合发起，华为全程赞助的权威项目\n  * 18周系统化训练，从Rust基础到编译器实战全覆盖\n  * 直接基于rustc源码进行教学和实践\n  * 提供向Rust官方仓库提交PR的真实机会\n\n- **技术路线**：\n  1. Rust基础强化（4周）\n  2. 编译器原理精讲（4周）\n  3. rustc架构深度解析（6周）\n  4. 真实Issue实战（4周）\n\n- **创新价值**：\n  * 国内首个专注于Rust编译器开发的训练项目\n  * 采用\"理论+源码+实战\"三位一体教学模式\n  * 打通从学习到实际贡献的完整路径\n  * 提供华为/南大/ISRC实习绿色通道\n\n- **适用人群**：\n  * 希望深入系统编程的Rust开发者\n  * 对编译器技术感兴趣的技术人员\n  * 有意向Rust官方贡献代码的开发者\n\n[项目意义]：\n该项目将显著提升国内Rust系统级开发能力，为rustc编译器培养潜在的核心贡献者，对推动Rust在中国的发展具有战略意义。\n\n报名链接：[https://opencamp.cn/rustcompiler/camp/2025fall/register?code=cFYDt2lDDaeyX](https://opencamp.cn/rustcompiler/camp/2025fall/register?code=cFYDt2lDDaeyX)  \n原文：[Rust中文社区公告](https://rustcc.cn/article?id=649caf46-48aa-497d-9d9a-8c84ce2eb0c8)\n\n## 招聘信息：Senior Rust Developer / 高级 Rust 开发工程师\n----------------------\n\n### 职位概览\n新加坡本地高级 Rust 开发岗位，提供 6,000-15,000 新币月薪，要求候选人具备 Rust 生产级系统开发经验。\n\n### 核心职责\n- **系统架构设计**：主导基于 Rust 的核心平台服务架构设计\n- **性能优化**：负责后端系统性能调优与架构改进\n- **分布式系统开发**：构建高可用、可扩展的微服务架构\n- **全栈协作**：与基础设施团队协作确保系统可观测性\n\n### 技术要求\n* **语言能力**：\n    - 精通 Rust 生产级应用开发\n    - 熟悉 Tokio/async-std 异步运行时\n    - 掌握 Actix/Axum 等 Web 框架\n* **系统知识**：\n    - 扎实的操作系统/网络/并发编程基础\n    - 分布式系统设计经验\n    - Redis/Kafka/Flink 等中间件实战经验\n* **工程实践**：\n    - 性能分析与调优能力\n    - 系统可观测性建设\n    - 代码质量与可维护性把控\n\n### 薪资与地点\n- **薪资范围**：6,000-15,000 SGD（约合 3-7.5 万人民币）\n- **工作模式**：新加坡现场办公（需本地居民或永久居留权）\n\n### 社区价值\n该职位反映了 Rust 在新加坡科技行业的应用趋势，特别是：\n1. 企业对 Rust 系统级能力的认可\n2. Rust 在高性能数据服务领域的实践\n3. 亚洲市场对 Rust 高级人才的迫切需求\n\n[原文链接](https://rustcc.cn/article?id=f76cc84c-6a3f-486f-a925-cd21f26a90d8)\n\n截图工具 - 功能丰富的Windows原生截图应用\n--------------\n\n这是一个使用Rust开发的Windows原生截图工具，展示了Rust在桌面应用开发中的强大能力。项目通过直接调用Windows API和Direct2D进行高性能图形渲染，提供了专业级的截图和标注功能。\n\n### 项目详细介绍：\n\n**项目目标和解决的问题**\n- 提供比Windows自带截图工具更丰富的功能集\n- 解决专业截图工具需要付费或安装复杂的问题\n- 展示Rust在Windows原生应用开发中的潜力\n\n**主要功能特点**\n* 📸 智能截图功能：\n  - 全屏/区域截图支持\n  - 窗口自动检测和高亮\n  - 实时预览选择区域\n* 🎨 专业绘图标注：\n  - 多种标注工具（矩形/圆形/箭头/自由画笔/文字）\n  - 自定义样式调节\n  - 操作撤销功能\n* 🔍 OCR文字识别：\n  - 集成PaddleOCR引擎\n  - 支持多语言识别（中/英/日/韩）\n  - 异步处理不阻塞界面\n* 📌 便捷功能：\n  - 窗口固钉功能\n  - 一键保存到剪贴板或文件\n  - 系统托盘运行+全局热键\n\n**技术特色和创新点**\n- 纯Rust实现，保证内存安全和性能\n- 直接调用Windows API实现深度系统集成\n- 使用Direct2D进行高性能图形渲染\n- 模块化设计便于维护扩展\n- OCR功能采用异步架构设计\n\n**使用示例**\n1. 运行程序后自动最小化到系统托盘\n2. 使用Ctrl+Alt+S热键或点击托盘图标启动截图\n3. 使用工具栏进行绘图标注\n4. 点击OCR按钮识别图片中的文字\n5. 保存到剪贴板、文件或固定到桌面\n\n**与现有方案对比**\n相比Windows自带截图工具，提供了更专业的标注功能和OCR识别；相比第三方商业软件，具有开源免费的优势；相比Electron类应用，具有更低的资源占用和更好的性能表现。\n\n仓库：[GitHub链接](https://github.com/han1548772930/sc_windows)\n\n\n--\n\nFrom 日报小组 Rust Daily"
}